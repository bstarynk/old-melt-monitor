/// *** generated file global.mom - DO NOT EDIT 
/// Copyright (C) 2015 Free Software Foundation, Inc. 
/// MONIMELT is a monitor for MELT - see http://gcc-melt.org/ 
/// This generated file global.mom is part of MONIMELT, part of GCC 
///
/// GCC is free software; you can redistribute it and/or modify 
/// it under the terms of the GNU General Public License as published by 
/// the Free Software Foundation; either version 3, or (at your option) 
/// any later version. 
///
///  GCC is distributed in the hope that it will be useful, 
///  but WITHOUT ANY WARRANTY; without even the implied warranty of 
///  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
///  GNU General Public License for more details. 
///  You should have received a copy of the GNU General Public License 
///  along with GCC; see the file COPYING3.   If not see 
///  <http://www.gnu.org/licenses/>. 
///

!! the_base_module


** _07BHLcwhp_48ka0t9bq
{
  * comment  "constant for hook of agenda_step"
  * value  ^agenda_step() }
 
..


** _14MzMbJ9v_627D0CIiA
{
  * comment  "block to apply varclo"
  * instructions  [] }
 
  %  ^filler_of_plain_kind( block)
 
..


** _1c462DJmx_68zwnz1Ua
{
  * comment  "set lkitm_agenda := the_agenda" }
 [[  set  lkitm_agenda  the_agenda ]]
 
  %  ^filler_of_plain_kind( code_statement)
 
..


** _44tmkDkKa_8nUhJEeay
{
  * comment  "if empty agenda refill it" }
 [[  if  ^queue_item_is_empty( lkitm_agenda)  _4xAIqB3tj_97IrD41UP ]]
 
  %  ^filler_of_plain_kind( code_statement)
 
..


** _4xAIqB3tj_97IrD41UP
{
  * comment  "refill empty agenda"
  * instructions  [_60nmad63F_1Jd336xAL _7vj8eaIrt_9bLBC6eKB] }
 
  %  ^filler_of_plain_kind( block)
 
..


** _60nmad63F_1Jd336xAL
{
  * comment  "set varclo := fill_agenda(lkitm_agenda)" }
 [[  set  varclo  ^unsync_get_attribute( lkitm_agenda  fill_agenda) ]]
 
  %  ^filler_of_plain_kind( code_statement)
 
..


** _7MF947fC8_8ChefReMD
{
  * comment  "starting block of agenda_step"
  * in  agenda_step
  * instructions  [_1c462DJmx_68zwnz1Ua _44tmkDkKa_8nUhJEeay] }
 
  %  ^filler_of_plain_kind( block)
 
..


** _7vj8eaIrt_9bLBC6eKB
{
  * comment  "if varclo apply it" }
 [[  if  varclo  _14MzMbJ9v_627D0CIiA ]]
 
  %  ^filler_of_plain_kind( code_statement)
 
..


** agenda_step   ////// PREDEFINED
{
  * constants  {_07BHLcwhp_48ka0t9bq fill_agenda the_agenda}
  * emitted_blocks  {_7MF947fC8_8ChefReMD}
  * emitted_closed  []
  * emitted_constants  [_07BHLcwhp_48ka0t9bq the_agenda]
  * emitted_variables  []
  * formals  []
  * function_signature  signature_void_to_void
  * hook_closure  0
  * in  the_base_module
  * start  _7MF947fC8_8ChefReMD
  * variable  [varclo] }
 [[  ^agenda_step() ]]
 
  %  ^filler_of_function( signature_void_to_void)
 
..


** apply   ////// PREDEFINED
{
  * comment  "opcode for apply <signature> <results...> <fun> <args...> [<else-block>] statement"
 }
 
..


** association   ////// PREDEFINED
{
  * comment  "kind of items with hashed attribute payload"
  * dumped_item_emitter  ^emitter_of_association()
  * dumped_item_scanner  ^scanner_of_association() }
 
..


** block   ////// PREDEFINED
{
  * comment  "kind for code blocks"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** case   ////// PREDEFINED
{
  * comment  "node for cases in int_switch or item_switch statements: case(<case-const>,<block-item>)"
 }
 
..


** chunk   ////// PREDEFINED
{
  * comment  "operation for C code chunk" }
 
..


** closed   ////// PREDEFINED
{
  * comment  "to give set or tuple of closed values in a function" }
 
..


** code   ////// PREDEFINED
{
  * comment  "gives the code for something" }
 
..


** code_emitter   ////// PREDEFINED
{
  * comment  "gives the closure to emit code" }
 
..


** code_expansion   ////// PREDEFINED
{
  * comment  "attributes giving the code expansion" }
 
..


** code_generation   ////// PREDEFINED
{
  * comment  "kind of transient items for code generation" }
 
..


** code_module   ////// PREDEFINED
{
  * comment  "kind of code modules"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** code_operation   ////// PREDEFINED
{
  * comment  "kind for (user-provided) code operations"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** code_statement   ////// PREDEFINED
{
  * comment  "kind of each instruction in a block"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** code_type_scanner   ////// PREDEFINED
{
  * comment  "gives the closure to scan a node" }
 
..


** comment   ////// PREDEFINED
{
  * comment  "to give comments in items." }
 
..


** constant   ////// PREDEFINED
{
  * comment  "kind of constant" }
 
..


** constants   ////// PREDEFINED
{
  * comment  "to give set or tuple of constant values in a function" }
 
..


** count
{
  * comment  "usual count in variadic operations"
  * type  integer }
 
..


** double   ////// PREDEFINED
{
  * comment  "type for double" }
 
..


** dumped_item_emitter   ////// PREDEFINED
{
  * comment  "within a kind, gives the closure applied to all items of that kind giving its transformer."
 }
 
..


** dumped_item_scanner   ////// PREDEFINED
{
  * comment  "within a kind, gives the closure applied to all items of that kind to scan it."
 }
 
..


** emitted_blocks   ////// PREDEFINED
{
  * comment  "attribute giving the emitted blocks inside a function" }
 
..


** emitted_closed   ////// PREDEFINED
{
  * comment  "attribute giving emitted closed values in function" }
 
..


** emitted_constants   ////// PREDEFINED
{
  * comment  "attribute giving emitted constants in function" }
 
..


** emitted_functions   ////// PREDEFINED
{
  * comment  "attribute giving the emitted functions inside a module" }
 
..


** emitted_variables   ////// PREDEFINED
{
  * comment  "attribute giving emitted variables in function" }
 
..


** emitter_of_association   ////// PREDEFINED
{
  * comment  "emitter routine for association items" }
 
  %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_function   ////// PREDEFINED
{
  * comment  "routine to emit C functions" }
 
  %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_hashed_set   ////// PREDEFINED
{
  * comment  "emitter routine for hashed set items" }
 
  %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_item_queue   ////// PREDEFINED
{
  * comment  "emitter for item_queue" }
 
  %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_magic_attribute   ////// PREDEFINED
{
  * comment  "predefined routine to emit magic_attribute-s" }
 
  %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_plain_kind   ////// PREDEFINED
{
  * comment  "routine to emit play kind items" }
 
  %  ^filler_of_function( signature_1itm_to_val)
 
..


** fail   ////// PREDEFINED
{
  * comment  "opcode to return with failure" }
 
..


** fill_agenda
{
  * comment  "attribute in agenda to refill it" }
 
..


** filler_of_association   ////// PREDEFINED
{
  * comment  "filler routine for association items" }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_function   ////// PREDEFINED
{
  * comment  "routine to fill loaded C functions" }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_hashed_set   ////// PREDEFINED
{
  * comment  "filler routine for hashed set items" }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_item_queue   ////// PREDEFINED
{
  * comment  "filler for item_queue" }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_magic_attribute   ////// PREDEFINED
{
  * comment  "function to fill a magic attribute" }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_plain_kind   ////// PREDEFINED
{
  * comment  "routine to fill plain kind items" }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** formals   ////// PREDEFINED
{
  * comment  "attribute giving the tuple of formals" }
 
..


** function_info   ////// PREDEFINED
{
  * comment  "gives internal information about functions" }
 
..


** function_radix   ////// PREDEFINED
{
  * comment  "gives the radix of names related to signatures & functions"
 }
 
..


** function_signature   ////// PREDEFINED
{
  * comment  "kind of function signatures"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** functions   ////// PREDEFINED
{
  * comment  "in a C module, attribute giving the set or tuple of functions, or a closure to compute them"
 }
 
..


** generate_c_module   ////// PREDEFINED
{
  * comment  "routine to generate a C module; returns the item on success, or an error message"
  * hook_closure  0 }
 [[  ^generate_c_module() ]]
 
  %  ^filler_of_function( signature_1itm_to_val)
 
..


** hashed_set   ////// PREDEFINED
{
  * comment  "kind of item with hashed set payload"
  * dumped_item_emitter  ^emitter_of_hashed_set()
  * dumped_item_scanner  ^scanner_of_hashed_set() }
 
..


** hook_closure   ////// PREDEFINED
{
  * comment  "attribute to give the hook closure in predefined functions"
 }
 
..


** if   ////// PREDEFINED
{
  * comment  "opcode for if <expr> <then-block> instruction" }
 
..


** in   ////// PREDEFINED
{
  * comment  "attribute giving some container information" }
 
..


** input_types   ////// PREDEFINED
{
  * comment  "give the tuple of input types inside signatures" }
 
..


** instructions   ////// PREDEFINED
{
  * comment  "attribute giving the tuple of instruction inside a block" }
 
..


** int_switch   ////// PREDEFINED
{
  * comment  "operation for switch on integer: int_switch <expr> <case>..."
 }
 
..


** integer   ////// PREDEFINED
{
  * code  "intptr_t"
  * comment  "type for intptr_t" }
 
  %  ^filler_of_plain_kind( type)
 
..


** item   ////// PREDEFINED
{
  * code  "momitem_t*"
  * comment  "type for momitem_t*" }
 
  %  ^filler_of_plain_kind( type)
 
..


** item_queue   ////// PREDEFINED
{
  * comment  "kind of queueitem-payloaded items"
  * dumped_item_emitter  ^emitter_of_item_queue()
  * dumped_item_scanner  ^scanner_of_item_queue() }
 
..


** item_switch   ////// PREDEFINED
{
  * comment  "operation for switch on item: item_switch <expr> <case>..."
 }
 
..


** itm1
{
  * type  item }
 
..


** itm2
{
  * type  item }
 
..


** jump   ////// PREDEFINED
{
  * comment  "operation for jump instruction" }
 
..


** kind   ////// PREDEFINED
{
  * comment  "very magic pseudo attribute giving the kind of items" }
 
..


** lkitm_agenda
{
  * comment  "the locked item for the agenda"
  * type  locked_item }
 
  %  ^filler_of_plain_kind( variable)
 
..


** locked_item   ////// PREDEFINED
{
  * code  "momlockeditem_t*"
  * comment  "type for \"momlockeditem_t*\"" }
 
  %  ^filler_of_plain_kind( type)
 
..


** magic_attribute   ////// PREDEFINED
{
  * comment  "kind of magic attributes"
  * dumped_item_emitter  ^emitter_of_magic_attribute()
  * dumped_item_scanner  ^scanner_of_magic_attribute() }
 
..


** node
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/node:*/ mom_make_node("  itm1  ", "
    count  ","  restitm  ")")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operation for making nodes"
  * formals  [itm1]
  * type  value
  * variadic_count  count
  * variadic_rest  restitm }
 
..


** output_types   ////// PREDEFINED
{
  * comment  "give the tuple of result types inside signatures" }
 
..


** plain_code_emitter
{
  * comment  "function to emit plain operator" }
 
  %  ^filler_of_function( signature_1itm1val_to_void)
 
..


** plain_code_type_scanner
{
  * comment  "function to scan plain operator" }
 
  %  ^filler_of_function( signature_1itm1val_to_item)
 
..


** preparation   ////// PREDEFINED
{
  * comment  "attribute giving the closure to prepare something, e.g. a code module"
 }
 
..


** queue_item_is_empty
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*queue_item_is_empty:*/"  itm1  " && "
    itm1  "->itm_kind == MOM_PREDEFINED_NAMED(item_queue) "  " && mom_queueitem_size ("
    itm1  "->itm_data1) == 0")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "test if a queue item is empty"
  * formals  [itm1]
  * type  integer }
 
  %  ^filler_of_plain_kind( code_operation)
 
..


** restitm
{
  * type  item }
 
..


** scanner_of_association   ////// PREDEFINED
{
  * comment  "scanner routine for association items" }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** scanner_of_function   ////// PREDEFINED
{
  * comment  "scanning routine for C functions, may add their containing module"
 }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** scanner_of_hashed_set   ////// PREDEFINED
{
  * comment  "scanner routine for hashed set items" }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** scanner_of_item_queue   ////// PREDEFINED
{
  * comment  "scanner for item_queue" }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** scanner_of_magic_attribute   ////// PREDEFINED
{
  * comment  "predefined routine to scan magic_attribute-s" }
 
  %  ^filler_of_function( signature_1itm_to_void)
 
..


** set   ////// PREDEFINED
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/set:*/ mom_setv_new("  count  ","
    restitm  ")")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operation for assignment instruction, also for making sets"
  * formals  []
  * type  value
  * variadic_count  count
  * variadic_rest  restitm }
 
..


** signature_1itm1val_to_item   ////// PREDEFINED
{
  * comment  "signature of functions taking one item, one value and giving a value"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm1val_to_item"
  * input_types  [item value]
  * output_types  [item] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1itm1val_to_void   ////// PREDEFINED
{
  * comment  "signature of functions taking one item, one value and giving no results"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm1val_to_void"
  * input_types  [item value]
  * output_types  [] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1itm_to_val   ////// PREDEFINED
{
  * comment  "signature for function of 1 item argument and 1 value result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm_to_val"
  * input_types  [item]
  * output_types  [value] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1itm_to_void   ////// PREDEFINED
{
  * comment  "signature for function of 1 item argument and no result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm_to_void"
  * input_types  [item]
  * output_types  [] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1val_to_val   ////// PREDEFINED
{
  * comment  "signature for closures with one value argument and one value result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1val_to_val"
  * input_types  [value]
  * output_types  [value] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1val_to_void   ////// PREDEFINED
{
  * comment  "signature for closures with one value argument and no result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1val_to_void"
  * input_types  [value]
  * output_types  [] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm1val_to_val   ////// PREDEFINED
{
  * comment  "signature of functions taking two items and a value and giving a value"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2itm1val_to_val"
  * input_types  [item item value]
  * output_types  [value] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm1val_to_void   ////// PREDEFINED
{
  * comment  "signature of functions taking two items and a value and giving no result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2itm1val_to_void"
  * input_types  [item item value]
  * output_types  [] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm_to_val   ////// PREDEFINED
{
  * comment  "signature of functions taking two items and giving one value"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2itm_to_val"
  * input_types  [item item]
  * output_types  [value] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm_to_void   ////// PREDEFINED
{
  * comment  "signature of functions taking two items giving no result"
  * function_radix  "2itm_to_void"
  * input_types  [item item]
  * output_types  [] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** signature_void_to_void   ////// PREDEFINED
{
  * comment  "signature for closures with no arguments and no result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "void_to_void"
  * input_types  []
  * output_types  [] }
 
  %  ^filler_of_plain_kind( function_signature)
 
..


** start   ////// PREDEFINED
{
  * comment  "attribute giving the starting attribute" }
 
..


** statement_emitter   ////// PREDEFINED
{
  * comment  "attribute giving the emitting closure in code operations" }
 
..


** statement_scanner   ////// PREDEFINED
{
  * comment  "attribute giving the scanning closure in code operations" }
 
..


** success   ////// PREDEFINED
{
  * comment  "opcode to return successfully" }
 
..


** tasklet   ////// PREDEFINED
{
  * comment  "kind for tasklets inside the_agenda" }
 
..


** the_agenda   ////// PREDEFINED
{
  * comment  "agenda queue of tasklets" }
 
  %  ^filler_of_item_queue( [])
 
..


** the_base_module   ////// PREDEFINED
{
  * comment  "the base module, notably for agenda functions"
  * emitted_functions  {agenda_step}
  * functions  {agenda_step} }
 
  %  ^filler_of_plain_kind( code_module)
 
..


** the_software   ////// PREDEFINED
{
  * comment  "describes the entire software system" }
 [[  test_module  plain_code_type_scanner  plain_code_emitter  value_of_item
   value_to_item  tuple  node  queue_item_is_empty  unsync_get_attribute
 ]]
 
..


** tuple
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/tuple:*/ mom_make_tuple("  count 
   ","  restitm  ")")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operation for making tuples"
  * formals  []
  * type  value
  * variadic_count  count
  * variadic_rest  restitm }
 
..


** type   ////// PREDEFINED
{
  * comment  "kind of code types, etc.."
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** unsync_get_attribute
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*unsync_get_attribute:*/mom_item_unsync_get_attribute ("
    itm1  ","  itm2  ")")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "get an attribute"
  * formals  [itm1 itm2]
  * type  value }
 
  %  ^filler_of_plain_kind( code_operation)
 
..


** val1
{
  * type  value }
 
..


** value   ////// PREDEFINED
{
  * code  "momvalue_t"
  * comment  "type for momvalue_t" }
 
  %  ^filler_of_plain_kind( type)
 
..


** value_of_item
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_of_item:*/ mom_itemv("  val1
    ")")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator to convert an item to a value"
  * formals  [itm1]
  * type  value }
 
..


** value_to_item
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_to_item:*/ mom_value_to_item("
    val1  ")")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator to convert a value to an item"
  * formals  [val1]
  * type  item }
 
..


** varclo
{
  * type  value }
 
  %  ^filler_of_plain_kind( variable)
 
..


** variable   ////// PREDEFINED
{
  * comment  "kind of variable, or attribute giving a set of variables"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** variadic_count   ////// PREDEFINED
{
  * comment  "in plain connectives, gives item bound to count of remaining arguments"
 }
 
..


** variadic_rest   ////// PREDEFINED
{
  * comment  "in plain connectives, gives item bound to rest of arguments"
 }
 
..


** void   ////// PREDEFINED
{
  * code  "void"
  * comment  "type for C \'void\' type" }
 
  %  ^filler_of_plain_kind( type)
 
..

//// end of global file global.mom
