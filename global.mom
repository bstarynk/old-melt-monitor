/// *** generated file global.mom - DO NOT EDIT 
/// Copyright (C) 2015 Free Software Foundation, Inc. 
/// MONIMELT is a monitor for MELT - see http://gcc-melt.org/ 
/// This generated file global.mom is part of MONIMELT, part of GCC 
///
/// GCC is free software; you can redistribute it and/or modify 
/// it under the terms of the GNU General Public License as published by 
/// the Free Software Foundation; either version 3, or (at your option) 
/// any later version. 
///
///  GCC is distributed in the hope that it will be useful, 
///  but WITHOUT ANY WARRANTY; without even the implied warranty of 
///  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
///  GNU General Public License for more details. 
///  You should have received a copy of the GNU General Public License 
///  along with GCC; see the file COPYING3.   If not see 
///  <http://www.gnu.org/licenses/>. 
///

!! the_base_module


** _01KbUac4A_3Jk2sUhJp
{
  * comment  "if argtasklets is sequence push them in back then notify; in agenda_push_back"
  * in  _0y7wu372C_3JH4an3L2 }
 [[  if  ^value_is_sequence( argtasklets)  _27PBmP9xP_3Hh1aedqr ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _02MHbyAxU_563vpdUu2
{
  * comment  "start block of agenda_push_front"
  * in  agenda_push_front
  * instructions  [_2P84CtHfA_4kF28e70H _7zujDCE1i_9m9ccD6C7 _8UcKkiiIk_2ur4xDt59
   _4kFw4Pe2j_7uh2m7JuM] }
 %  ^filler_of_plain_kind( block)
 
..


** _07BHLcwhp_48ka0t9bq
{
  * comment  "constant for hook of agenda_step"
  * value  ^agenda_step() }
 
..


** _0HvrqAHte_4ryaA4drs
{
  * comment  "block chunk-wait agenda-changed"
  * in  agenda_step
  * instructions  [_5a8Hrecb3_9evcyu8sh _46231jt3F_9IUe8xbwK _51n8x1e9t_76B1hJrwI]
 }
 %  ^filler_of_plain_kind( block)
 
..


** _0LHqbyzz9_2J9v5p6zc
{
  * comment  "block to push lkitm_tasklet in front of agenda and epilog; in agenda_push_front"
  * in  agenda_push_front
  * instructions  [_2AAHn6xi7_1R19bsnhn _9jMHbym6i_27j6eCiEL _6npzcxMDM_2I2dUIfMn]
 }
 %  ^filler_of_plain_kind( block)
 
..


** _0p7zBDIku_3njudUFtp
{
  * comment  "itmvar_tasklet <- pop_front(lkitm_agenda)"
  * in  _7MF947fC8_8ChefReMD }
 [[  pop_front_queue_item  itmvar_tasklet  lkitm_agenda ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _0t73aJCyK_6IRtxxHRn
{
  * comment  "otherwise -no funcset- fail ... in appfuntoclomod"
  * in  _9MARH5tjh_28MKpzxv3 }
 [[  fail ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _0y7wu372C_3JH4an3L2
{
  * comment  "start block of agenda_push_back"
  * in  agenda_push_back
  * instructions  [_2ur1uJ52w_1RmsKK5vb _6e0q8qCzJ_3ycbtIr58 _1m2L2Rncp_4uuzUDCqz
   _01KbUac4A_3Jk2sUhJp] }
 %  ^filler_of_plain_kind( block)
 
..


** _14MzMbJ9v_627D0CIiA
{
  * comment  "block to apply varclo to lkitm_agenda"
  * in  agenda_step
  * instructions  [_4KKszvz3w_1HLUHLsru] }
 %  ^filler_of_plain_kind( block)
 
..


** _1FU0vnqP4_6LLqBkKnt
{
  * comment  "broadcast agenda changed after pushing tasklet in agenda_push_front"
  * in  _4h7BHLiLB_9askynfAC }
 [[  chunk  "  pthread_cond_broadcast(&mom_agenda_changed_condvar);\n" ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _1R1KvIhCR_6ak3tU4ep
{
  * comment  "debug-printf pushed fron lkitm_tasklet in agenda_push_back"
  * in  _50yPKJAK2_4Ksihqd4c }
 [[  chunk  "  MOM_DEBUGPRINTF(run, \"agenda_push_back: pushed tasklet %s in back of the_agenda\",\n"
   "   mom_item_cstring("  lkitm_tasklet  "));\n" ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _1c462DJmx_68zwnz1Ua
{
  * comment  "set lkitm_agenda := the_agenda in agenda_step"
  * in  _7MF947fC8_8ChefReMD }
 [[  set  lkitm_agenda  the_agenda ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _1dhK6Bj47_4vvDyBKAR
{
  * comment  "if varclo is runner node, apply it to lkitm_tasklet"
  * in  _2tz000b51_1AEBtnP4P }
 [[  if  ^value_is_node( varclo)  _8aqavIeMK_2EHL44cnU ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _1m2L2Rncp_4uuzUDCqz
{
  * comment  "if lkitm_tasklet, push it back; in agenda_push_back"
  * in  _0y7wu372C_3JH4an3L2 }
 [[  if  lkitm_tasklet  _50yPKJAK2_4Ksihqd4c ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _1mhPemeyd_4k5enfKC3
{
  * comment  "set lkitm_fun <- itm1 ... in appfuntoclomod"
  * in  _9MARH5tjh_28MKpzxv3 }
 [[  set  lkitm_fun  itm1 ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _20wqLcAtc_09ciRnJLc
{
  * comment  "otherwise -no itmvar_funsig- fail ... in appfuntoclomod"
  * in  _4he2bnU93_5b5bkfLER }
 [[  fail ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _24sBAv42k_3Ly5hw0vj
{
  * comment  "push lkitm_tasklet at back of lkitm_agenda; in agenda_push_back"
  * in  _50yPKJAK2_4Ksihqd4c }
 [[  push_back_queue_item  lkitm_agenda  lkitm_tasklet ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _24z256FyK_7r8ApkvqK
{
  * comment  "set lkitm_tasklet := value_sequence_nth(argtasklets, varix); for agenda_push_front"
  * in  _7jkswmJf4_89dmJmBc2 }
 [[  set  lkitm_tasklet  ^value_sequence_nth( argtasklets  varix) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _27PBmP9xP_3Hh1aedqr
{
  * comment  "block to push every lkitm_tasklet in sequence argtasklets in back of agenda and notify"
  * in  agenda_push_back
  * instructions  [_5JFtUFwBC_1v2BUA42z _60v4pLRCu_55xI9BKJD _4bmJK3Ip5_22Dnmu5Hu]
 }
 %  ^filler_of_plain_kind( block)
 
..


** _27iRH5wiL_0Rmz4hwxv
{
  * comment  "broadcast agenda changed after pushing tasklet in agenda_push_back"
  * in  _2I2UdbsCL_6c82fexBk }
 [[  chunk  "  pthread_cond_broadcast(&mom_agenda_changed_condvar);\n" ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _2AAHn6xi7_1R19bsnhn
{
  * comment  "push lkitm_tasklet in front of lkitm_agenda; in agenda_push_front"
  * in  _0LHqbyzz9_2J9v5p6zc }
 [[  push_front_queue_item  lkitm_agenda  lkitm_tasklet ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _2CMuyktFw_5rt7PbyCD
{
  * comment  "block succeed agenda_step since stopping"
  * in  agenda_step
  * instructions  [_7H4dmCuFI_1C4PP5IBx] }
 %  ^filler_of_plain_kind( block)
 
..


** _2I2UdbsCL_6c82fexBk
{
  * comment  "blockepilog to notify in agenda_push_back"
  * in  agenda_push_back
  * instructions  [_27iRH5wiL_0Rmz4hwxv _9asfCiefD_1pRiIn679] }
 %  ^filler_of_plain_kind( block)
 
..


** _2P84CtHfA_4kF28e70H
{
  * comment  "set lkitm_agenda := the_agenda; in agenda_push_front"
  * in  _02MHbyAxU_563vpdUu2 }
 [[  set  lkitm_agenda  the_agenda ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _2Pjxm7fux_60FU0zy46
{
  * comment  "put in lkitm_module attribute `functions` the valvar_newfuncset "
  * in  _8xBt9K6Ch_2v6P4PEtw }
 [[  unsync_put_attribute  lkitm_module  functions  valvar_newfuncset ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _2ijiEhdMr_0E10qj6s8
{
  * comment  "if itmvar_funsig test-module ... in appfuntoclomod"
  * in  _9MARH5tjh_28MKpzxv3 }
 [[  if  itmvar_funsig  _4he2bnU93_5b5bkfLER ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _2tz000b51_1AEBtnP4P
{
  * comment  "lock and run the tasklet"
  * in  agenda_step
  * instructions  [_4zMbIKH13_6KmkUPLpd _2u1LykBw5_7IRf5Cjub _1dhK6Bj47_4vvDyBKAR]
 }
 %  ^filler_of_plain_kind( block)
 
..


** _2u1LykBw5_7IRf5Cjub
{
  * comment  "set varclo := get_attr(lkitm_tasklet, runner)"
  * in  _2tz000b51_1AEBtnP4P }
 [[  set  varclo  ^unsync_get_attribute( lkitm_tasklet  runner) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _2ur1uJ52w_1RmsKK5vb
{
  * comment  "set lkitm_agenda := the_agenda; in agenda_push_back"
  * in  _0y7wu372C_3JH4an3L2 }
 [[  set  lkitm_agenda  the_agenda ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _3243Pxefq_0KLe76cvy
{
  * comment  "debug-run lkitm_tasklet & varclo before running"
  * in  _8aqavIeMK_2EHL44cnU }
 [[  chunk  "  MOM_DEBUGPRINTF(run, \"before running tasklet %s using closure %s\",\n"
   "    mom_item_cstring("  lkitm_tasklet  "),  mom_output_gcstring("  varclo
   "));\n" ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _32pAfaaDd_1jeEvt083
{
  * comment  "push lkitm_tasklet in front of lkitm_tasklet; in agenda_push_front seq..."
  * in  _7jkswmJf4_89dmJmBc2 }
 [[  push_front_queue_item  lkitm_agenda  lkitm_tasklet ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _35ALykwdw_1UiPefUMH
{
  * comment  "success of agenda_push_front"
  * in  _4h7BHLiLB_9askynfAC }
 [[  success ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _3JddiuKnc_1nzuB6bss
{
  * comment  "block seqloop on argtasklets; in agenda_push_back"
  * in  agenda_push_back
  * instructions  [_61DxdHIjP_2U7hhsKDL _4qKLvc6ce_24ym1K7qm _60fFrKH58_32pCM7kxK
   _6UmR4hJ3a_9A2d4BdrJ _7qRm75s5I_9vzdpzm0K] }
 %  ^filler_of_plain_kind( block)
 
..


** _44tmkDkKa_8nUhJEeay
{
  * comment  "if empty agenda refill it"
  * in  _7MF947fC8_8ChefReMD }
 [[  if  ^queue_item_is_empty( lkitm_agenda)  _4xAIqB3tj_97IrD41UP ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _46231jt3F_9IUe8xbwK
{
  * comment  "clear lkitm_agenda to unlock it"
  * in  _0HvrqAHte_4ryaA4drs }
 [[  set  lkitm_agenda  ~ ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _4KKszvz3w_1HLUHLsru
{
  * comment  "apply varclo to lkitm_agenda"
  * in  _14MzMbJ9v_627D0CIiA }
 [[  apply  signature_1itm_to_void  varclo  the_agenda ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _4bmJK3Ip5_22Dnmu5Hu
{
  * comment  "jump to seqloop on argtasklets; in agenda_push_back"
  * in  _27PBmP9xP_3Hh1aedqr }
 [[  jump  _3JddiuKnc_1nzuB6bss ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _4cDEyFzEy_8frx4MEAH
{
  * comment  "if lkitm_module is a code_module ... in appfuntoclomod"
  * in  _4he2bnU93_5b5bkfLER }
 [[  if  ^item_has_kind( lkitm_module  code_module)  _8xBt9K6Ch_2v6P4PEtw
 ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _4h7BHLiLB_9askynfAC
{
  * comment  "blockepilog to notify in agenda_push_front"
  * in  agenda_push_front
  * instructions  [_1FU0vnqP4_6LLqBkKnt _35ALykwdw_1UiPefUMH] }
 %  ^filler_of_plain_kind( block)
 
..


** _4he2bnU93_5b5bkfLER
{
  * comment  "testmodule block of append_function_to_closed_module"
  * in  append_function_to_closed_module
  * instructions  [_4cDEyFzEy_8frx4MEAH _20wqLcAtc_09ciRnJLc] }
 %  ^filler_of_plain_kind( block)
 
..


** _4kFw4Pe2j_7uh2m7JuM
{
  * comment  "if argtasklets is sequence push them in front then notify; in agenda_push_front"
  * in  _02MHbyAxU_563vpdUu2 }
 [[  if  ^value_is_sequence( argtasklets)  _9m9aprPJz_4hExeiqIi ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _4qKLvc6ce_24ym1K7qm
{
  * comment  "set lkitm_tasklet := value_sequence_nth(argtasklets, varix); for agenda_push_back"
  * in  _3JddiuKnc_1nzuB6bss }
 [[  set  lkitm_tasklet  ^value_sequence_nth( argtasklets  varix) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _4sni2unK9_1AqEEbhcc
{
  * comment  "varlen := length of argtasklets; in agenda_push_front"
  * in  _9m9aprPJz_4hExeiqIi }
 [[  set  varlen  ^value_sequence_length( argtasklets) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _4xAIqB3tj_97IrD41UP
{
  * comment  "refill empty agenda"
  * in  agenda_step
  * instructions  [_60nmad63F_1Jd336xAL _7vj8eaIrt_9bLBC6eKB _6kDqRmkjk_6CxUEu2hk]
 }
 %  ^filler_of_plain_kind( block)
 
..


** _4zMbIKH13_6KmkUPLpd
{
  * comment  "set lkitm_tasklet := itmvar_tasklet"
  * in  _2tz000b51_1AEBtnP4P }
 [[  set  lkitm_tasklet  itmvar_tasklet ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _50yPKJAK2_4Ksihqd4c
{
  * comment  "block to push lkitm_tasklet in back of agenda and epilog; in agenda_push_back"
  * in  agenda_push_back
  * instructions  [_24sBAv42k_3Ly5hw0vj _1R1KvIhCR_6ak3tU4ep _6pte4hEqb_94D0cHswb]
 }
 %  ^filler_of_plain_kind( block)
 
..


** _50yPKJrza_50B8EJ0LA
{
  * comment  "set valvar_newfuncset augmenting vavar_funcset ... in appfuntoclomod"
  * in  _8xBt9K6Ch_2v6P4PEtw }
 [[  set  valvar_newfuncset  ^collect_set( valvar_funcset  ^value_of_item(
    lkitm_fun)) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _50yPKJtuB_0LhHHcP39
{
  * comment  "chunk inform about the updated module in appfuntoclomod"
  * in  _8xBt9K6Ch_2v6P4PEtw }
 [[  chunk  "MOM_INFORMPRINTF(\"updated functions of module %s from %s to %s\", \n"
   "    mom_item_cstring("  lkitm_module  "),"  " mom_output_gcstring(" 
  valvar_funcset  "), "  " mom_output_gcstring("  valvar_newfuncset  ")"
   ");\n" ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _51n8x1e9t_76B1hJrwI
{
  * comment  "jump start agenda_step"
  * in  _0HvrqAHte_4ryaA4drs }
 [[  jump  _7MF947fC8_8ChefReMD ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _55xk4tfhF_5sUF6zmde
{
  * comment  "succeed agenda_step after tasklet running"
  * in  _8aqavIeMK_2EHL44cnU }
 [[  success ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _5Icpjuev3_8xCdCtMdD
{
  * comment  "set lkitm_module <- val2 ..., closed in appfuntoclomod"
  * in  _9MARH5tjh_28MKpzxv3 }
 [[  set  lkitm_module  ^value_to_item( val2) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _5JFtUFwBC_1v2BUA42z
{
  * comment  "varlen := length of argtasklets; in agenda_push_back"
  * in  _27PBmP9xP_3Hh1aedqr }
 [[  set  varlen  ^value_sequence_length( argtasklets) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _5a8Hrecb3_9evcyu8sh
{
  * comment  "instr chunk-wait agenda changed"
  * in  _0HvrqAHte_4ryaA4drs }
 [[  chunk  "/*chunk wait agenda changed*/\n"  "  struct timespec ts_"  this_statement
   " = {0,0};\n"  "  clock_gettime(CLOCK_REALTIME, &ts_"  this_statement
   ");\n"  "  ts_"  this_statement  ".tv_sec += MOM_AGENDA_WAIT_SEC;\n" 
  "  pthread_cond_timedwait(&mom_agenda_changed_condvar, &"  lkitm_agenda
   "->itm_mtx, & ts_"  this_statement  ");\n" ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _5hCHeHf33_2y4IR7sHP
{
  * comment  "set itmvar_funsig <- get(lkitm_fun, function_signature) ... in appfuntoclomod"
  * in  _9MARH5tjh_28MKpzxv3 }
 [[  set  itmvar_funsig  ^value_to_item( ^unsync_get_attribute( lkitm_fun
     function_signature)) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _60fFrKH58_32pCM7kxK
{
  * comment  "push lkitm_tasklet in back of lkitm_tasklet; in agenda_push_back seq..."
  * in  _3JddiuKnc_1nzuB6bss }
 [[  push_back_queue_item  lkitm_agenda  lkitm_tasklet ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _60nmad63F_1Jd336xAL
{
  * comment  "set varclo := fill_agenda(lkitm_agenda)"
  * in  _4xAIqB3tj_97IrD41UP }
 [[  set  varclo  ^unsync_get_attribute( lkitm_agenda  fill_agenda) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _60v4pLRCu_55xI9BKJD
{
  * comment  "varix := 0; in agenda_push_back"
  * in  _27PBmP9xP_3Hh1aedqr }
 [[  set  varix  0 ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _61DxdHIjP_2U7hhsKDL
{
  * comment  "if (varix>=varlen) goto epilogpushback; in agenda_push_back"
  * in  _3JddiuKnc_1nzuB6bss }
 [[  if  ^integer_greater_or_equal( varix  varlen)  _2I2UdbsCL_6c82fexBk
 ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _67HCKpy4n_17u81x1Cz
{
  * comment  "varix := 0; in agenda_push_front"
  * in  _9m9aprPJz_4hExeiqIi }
 [[  set  varix  0 ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _6PukHeHkL_5rxkpnFsJ
{
  * comment  "if (varix>=varlen) goto epilogpushfront; in agenda_push_front"
  * in  _7jkswmJf4_89dmJmBc2 }
 [[  if  ^integer_greater_or_equal( varix  varlen)  _4h7BHLiLB_9askynfAC
 ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _6UmR4hJ3a_9A2d4BdrJ
{
  * comment  "increment varix ; in agenda_push_back seq..."
  * in  _3JddiuKnc_1nzuB6bss }
 [[  set  varix  ^integer_add( varix  1) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _6e0q8qCzJ_3ycbtIr58
{
  * comment  "set lkitm_tasklet := value_to_item(argtasklets); in agenda_push_back"
  * in  _0y7wu372C_3JH4an3L2 }
 [[  set  lkitm_tasklet  ^value_to_item( argtasklets) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _6kDqRmkjk_6CxUEu2hk
{
  * comment  "if lkitm_agenda empty queue wait agenda-changed"
  * in  _4xAIqB3tj_97IrD41UP }
 [[  if  ^queue_item_is_empty( lkitm_agenda)  _0HvrqAHte_4ryaA4drs ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _6npzcxMDM_2I2dUIfMn
{
  * comment  "jump to epilog of agenda_push_front"
  * in  _0LHqbyzz9_2J9v5p6zc }
 [[  jump  _4h7BHLiLB_9askynfAC ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _6pte4hEqb_94D0cHswb
{
  * comment  "jump to epilog of agenda_push_back"
  * in  _50yPKJAK2_4Ksihqd4c }
 [[  jump  _2I2UdbsCL_6c82fexBk ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _6r8vRwBre_0c5UpIM8y
{
  * comment  "apply varclo to lkitm_tasklet for running"
  * in  _8aqavIeMK_2EHL44cnU }
 [[  apply  signature_1itm_to_void  varclo  lkitm_tasklet ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _6xfMIeeHE_66yBKz8u6
{
  * comment  "succeed in appfuntoclomod"
  * in  _8xBt9K6Ch_2v6P4PEtw }
 [[  success ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _7H4dmCuFI_1C4PP5IBx
{
  * comment  "succeed agenda_step when stopping"
  * in  _2CMuyktFw_5rt7PbyCD }
 [[  success ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _7MF947fC8_8ChefReMD
{
  * comment  "starting block of agenda_step"
  * in  agenda_step
  * instructions  [_1c462DJmx_68zwnz1Ua _9kCFcc1xu_2s0E2MiAa _44tmkDkKa_8nUhJEeay
   _0p7zBDIku_3njudUFtp _9MCjbp28L_6zLA3KERH] }
 %  ^filler_of_plain_kind( block)
 
..


** _7e0I1v1zU_9Ibu5v8Iw
{
  * comment  "jump to seqloop on argtasklets; in agenda_push_front"
  * in  _9m9aprPJz_4hExeiqIi }
 [[  jump  _7jkswmJf4_89dmJmBc2 ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _7jkswmJf4_89dmJmBc2
{
  * comment  "block seqloop on argtasklets; in agenda_push_front"
  * in  agenda_push_front
  * instructions  [_6PukHeHkL_5rxkpnFsJ _24z256FyK_7r8ApkvqK _32pAfaaDd_1jeEvt083
   _9A2akip87_18CiHx1db _8HabUa62b_311b5M6qe] }
 %  ^filler_of_plain_kind( block)
 
..


** _7qRm75s5I_9vzdpzm0K
{
  * comment  "jump block seqloop; in agenda_push_back seq... "
  * in  _3JddiuKnc_1nzuB6bss }
 [[  jump  _3JddiuKnc_1nzuB6bss ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _7s4IHrpuh_90FeBfefy
{
  * comment  "debug-run lkitm_tasklet after running"
  * in  _8aqavIeMK_2EHL44cnU }
 [[  chunk  "  MOM_DEBUGPRINTF(run, \"after running tasklet %s\\n\",\n" 
  "    mom_item_cstring("  lkitm_tasklet  "));\n" ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _7vj8eaIrt_9bLBC6eKB
{
  * comment  "if varclo is node apply it"
  * in  _4xAIqB3tj_97IrD41UP }
 [[  if  ^value_is_node( varclo)  _14MzMbJ9v_627D0CIiA ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _7zujDCE1i_9m9ccD6C7
{
  * comment  "set lkitm_tasklet := value_to_item(argtasklets); in agenda_push_front"
  * in  _02MHbyAxU_563vpdUu2 }
 [[  set  lkitm_tasklet  ^value_to_item( argtasklets) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _8HabUa62b_311b5M6qe
{
  * comment  "jump block seqloop; in agenda_push_front "
  * in  _7jkswmJf4_89dmJmBc2 }
 [[  jump  _7jkswmJf4_89dmJmBc2 ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _8UcKkiiIk_2ur4xDt59
{
  * comment  "if lkitm_tasklet, push it front; in agenda_push_front"
  * in  _02MHbyAxU_563vpdUu2 }
 [[  if  lkitm_tasklet  _0LHqbyzz9_2J9v5p6zc ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _8aqavIeMK_2EHL44cnU
{
  * comment  "apply varclo to lkitm_tasklet and succeed"
  * in  agenda_step
  * instructions  [_3243Pxefq_0KLe76cvy _6r8vRwBre_0c5UpIM8y _7s4IHrpuh_90FeBfefy
   _55xk4tfhF_5sUF6zmde] }
 %  ^filler_of_plain_kind( block)
 
..


** _8ePmCtD84_0yERvJzrB
{
  * comment  "get in valvar_funcset functions of module ... in appfuntoclomod"
  * in  _8xBt9K6Ch_2v6P4PEtw }
 [[  set  valvar_funcset  ^unsync_get_attribute( lkitm_module  functions)
 ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _8xBt9K6Ch_2v6P4PEtw
{
  * comment  "get in valvar_funcset functions block of append_function_to_closed_module"
  * in  append_function_to_closed_module
  * instructions  [_8ePmCtD84_0yERvJzrB _50yPKJrza_50B8EJ0LA _2Pjxm7fux_60FU0zy46
   _50yPKJtuB_0LhHHcP39 _6xfMIeeHE_66yBKz8u6] }
 %  ^filler_of_plain_kind( block)
 
..


** _9A2akip87_18CiHx1db
{
  * comment  "increment varix ; in agenda_push_front seq..."
  * in  _7jkswmJf4_89dmJmBc2 }
 [[  set  varix  ^integer_add( varix  1) ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _9MARH5tjh_28MKpzxv3
{
  * comment  "start block of append_function_to_closed_module"
  * in  append_function_to_closed_module
  * instructions  [_1mhPemeyd_4k5enfKC3 _5Icpjuev3_8xCdCtMdD _5hCHeHf33_2y4IR7sHP
   _2ijiEhdMr_0E10qj6s8 _0t73aJCyK_6IRtxxHRn] }
 %  ^filler_of_plain_kind( block)
 
..


** _9MCjbp28L_6zLA3KERH
{
  * comment  "if itmvar_tasklet is a tasklet run it"
  * in  _7MF947fC8_8ChefReMD }
 [[  if  ^item_has_kind( itmvar_tasklet  tasklet)  _2tz000b51_1AEBtnP4P ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _9asfCiefD_1pRiIn679
{
  * comment  "success of agenda_push_back"
  * in  _2I2UdbsCL_6c82fexBk }
 [[  success ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _9jMHbym6i_27j6eCiEL
{
  * comment  "debug-printf pushed fron lkitm_tasklet in agenda_push_front"
  * in  _0LHqbyzz9_2J9v5p6zc }
 [[  chunk  "  MOM_DEBUGPRINTF(run, \"agenda_push_front: pushed tasklet %s in front of the_agenda\",\n"
   "   mom_item_cstring("  lkitm_tasklet  "));\n" ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _9kCFcc1xu_2s0E2MiAa
{
  * comment  "if should_stop succeed in agenda_step"
  * in  _7MF947fC8_8ChefReMD }
 [[  if  ^should_stop()  _2CMuyktFw_5rt7PbyCD ]]
 %  ^filler_of_plain_kind( code_statement)
 
..


** _9m9aprPJz_4hExeiqIi
{
  * comment  "block to push every lkitm_tasklet in sequence argtasklets in front of agenda and notify"
  * in  agenda_push_front
  * instructions  [_4sni2unK9_1AqEEbhcc _67HCKpy4n_17u81x1Cz _7e0I1v1zU_9Ibu5v8Iw]
 }
 %  ^filler_of_plain_kind( block)
 
..


** agenda_push_back   ////// PREDEFINED
{
  * comment  "hook to push a tasklet or a set or tuple of them in back of the agenda"
  * constants  {item_queue tasklet the_agenda}
  * emitted_blocks  {_0y7wu372C_3JH4an3L2 _27PBmP9xP_3Hh1aedqr _2I2UdbsCL_6c82fexBk
   _3JddiuKnc_1nzuB6bss _50yPKJAK2_4Ksihqd4c}
  * emitted_closed  []
  * emitted_constants  [hook_closure item_queue tasklet the_agenda]
  * emitted_variables  [lkitm_agenda lkitm_tasklet varlen varix]
  * formals  [argtasklets]
  * function_signature  signature_1val_to_void
  * hook_closure  0
  * in  the_base_module
  * start  _0y7wu372C_3JH4an3L2 }
 [[  ^agenda_push_back()  item_queue  tasklet  the_agenda ]]
 %  ^filler_of_function( signature_1val_to_void)
 
..


** agenda_push_front   ////// PREDEFINED
{
  * comment  "hook to push a tasklet or a set or tuple of them in front of the agenda"
  * constants  {item_queue tasklet the_agenda}
  * emitted_blocks  {_02MHbyAxU_563vpdUu2 _0LHqbyzz9_2J9v5p6zc _4h7BHLiLB_9askynfAC
   _7jkswmJf4_89dmJmBc2 _9m9aprPJz_4hExeiqIi}
  * emitted_closed  []
  * emitted_constants  [hook_closure item_queue tasklet the_agenda]
  * emitted_variables  [lkitm_agenda lkitm_tasklet varlen varix]
  * formals  [argtasklets]
  * function_signature  signature_1val_to_void
  * hook_closure  0
  * in  the_base_module
  * start  _02MHbyAxU_563vpdUu2 }
 [[  ^agenda_push_front()  item_queue  tasklet  the_agenda ]]
 %  ^filler_of_function( signature_1val_to_void)
 
..


** agenda_step   ////// PREDEFINED
{
  * constants  {_07BHLcwhp_48ka0t9bq fill_agenda item_queue runner tasklet
   the_agenda}
  * emitted_blocks  {_0HvrqAHte_4ryaA4drs _14MzMbJ9v_627D0CIiA _2CMuyktFw_5rt7PbyCD
   _2tz000b51_1AEBtnP4P _4xAIqB3tj_97IrD41UP _7MF947fC8_8ChefReMD _8aqavIeMK_2EHL44cnU}
  * emitted_closed  []
  * emitted_constants  [hook_closure _07BHLcwhp_48ka0t9bq fill_agenda item_queue
   runner tasklet the_agenda]
  * emitted_variables  [varclo lkitm_agenda itmvar_tasklet lkitm_tasklet]
  * formals  []
  * function_signature  signature_void_to_void
  * hook_closure  0
  * in  the_base_module
  * start  _7MF947fC8_8ChefReMD
  * variable  [varclo] }
 [[  ^agenda_step()  fill_agenda  ^agenda_step()  item_queue  runner  tasklet
   the_agenda ]]
 %  ^filler_of_function( signature_void_to_void)
 
..


** append_function_to_closed_module
{
  * closed  [val2]
  * comment  "append argument function itm1 to module closed val2"
  * constants  [function_signature code_module functions]
  * emitted_blocks  {_4he2bnU93_5b5bkfLER _8xBt9K6Ch_2v6P4PEtw _9MARH5tjh_28MKpzxv3}
  * emitted_closed  [val2]
  * emitted_constants  [function_signature code_module functions]
  * emitted_variables  [itmvar_funsig valvar_funcset valvar_newfuncset lkitm_fun
   lkitm_module]
  * formals  [itm1]
  * function_signature  signature_1itm_to_void
  * in  the_base_module
  * start  _9MARH5tjh_28MKpzxv3
  * variable  [itmvar_funsig valvar_funcset valvar_newfuncset] }
 [[  code_module  function_signature  functions ]]
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** apply   ////// PREDEFINED
{
  * comment  "opcode for apply <signature> <results...> <fun> <args...> [<else-block>] statement"
 }
 
..


** argtasklets
{
  * comment  "argument for tasklets to push into agenda"
  * type  value }
 
..


** association   ////// PREDEFINED
{
  * comment  "kind of items with hashed attribute payload"
  * dumped_item_emitter  ^emitter_of_association()
  * dumped_item_scanner  ^scanner_of_association() }
 
..


** batch_process   ////// PREDEFINED
{
  * comment  "for batch processes" }
 
..


** block   ////// PREDEFINED
{
  * comment  "kind for code blocks"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** case   ////// PREDEFINED
{
  * comment  "node for cases in int_switch or item_switch statements: case(<case-const>,<block-item>)"
 }
 
..


** chunk   ////// PREDEFINED
{
  * comment  "operation for C code chunk" }
 
..


** closed   ////// PREDEFINED
{
  * comment  "to give set or tuple of closed values in a function" }
 
..


** code   ////// PREDEFINED
{
  * comment  "gives the code for something" }
 
..


** code_emitter   ////// PREDEFINED
{
  * comment  "gives the closure to emit code" }
 
..


** code_expansion   ////// PREDEFINED
{
  * comment  "attributes giving the code expansion" }
 
..


** code_generation   ////// PREDEFINED
{
  * comment  "kind of transient items for code generation" }
 
..


** code_module   ////// PREDEFINED
{
  * comment  "kind of code modules"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** code_operation   ////// PREDEFINED
{
  * comment  "kind for (user-provided) code operations"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** code_statement   ////// PREDEFINED
{
  * comment  "kind of each instruction in a block"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** code_type_scanner   ////// PREDEFINED
{
  * comment  "gives the closure to scan a node" }
 
..


** collect_set
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*collect_set:*/ mom_collect_setv("
    count  ","  restval  ", NULL)")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operation for collecting sets"
  * formals  []
  * type  value
  * variadic_count  count
  * variadic_rest  restval }
 
..


** collect_tuple
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*collect_tuple:*/ mom_collect_tuplev("
    count  ","  restval  ", NULL)")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operation for collecting tuples"
  * formals  []
  * type  value
  * variadic_count  count
  * variadic_rest  restval }
 
..


** comment   ////// PREDEFINED
{
  * comment  "to give comments in items." }
 
..


** constant   ////// PREDEFINED
{
  * comment  "kind of constant" }
 
..


** constants   ////// PREDEFINED
{
  * comment  "to give set or tuple of constant values in a function" }
 
..


** count
{
  * comment  "usual count in variadic operations"
  * type  integer }
 
..


** delim_type
{
  * code  "momty_delim"
  * comment  "integer constant for delim value type" }
 %  ^filler_of_plain_kind( integer)
 
..


** double   ////// PREDEFINED
{
  * comment  "type for double" }
 
..


** double_type
{
  * code  "momty_double"
  * comment  "integer constant for double value type"
  * in  double }
 %  ^filler_of_plain_kind( integer)
 
..


** dumped_item_emitter   ////// PREDEFINED
{
  * comment  "within a kind, gives the closure applied to all items of that kind giving its transformer."
 }
 
..


** dumped_item_scanner   ////// PREDEFINED
{
  * comment  "within a kind, gives the closure applied to all items of that kind to scan it."
 }
 
..


** emitted_blocks   ////// PREDEFINED
{
  * comment  "attribute giving the emitted blocks inside a function" }
 
..


** emitted_closed   ////// PREDEFINED
{
  * comment  "attribute giving emitted closed values in function" }
 
..


** emitted_constants   ////// PREDEFINED
{
  * comment  "attribute giving emitted constants in function" }
 
..


** emitted_functions   ////// PREDEFINED
{
  * comment  "attribute giving the emitted functions inside a module" }
 
..


** emitted_variables   ////// PREDEFINED
{
  * comment  "attribute giving emitted variables in function" }
 
..


** emitter_of_association   ////// PREDEFINED
{
  * comment  "emitter routine for association items" }
 %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_function   ////// PREDEFINED
{
  * comment  "routine to emit C functions" }
 %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_hashed_dict   ////// PREDEFINED
{
  * comment  "emitter routine for hashed dict items" }
 %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_hashed_set   ////// PREDEFINED
{
  * comment  "emitter routine for hashed set items" }
 %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_item_queue   ////// PREDEFINED
{
  * comment  "emitter for item_queue" }
 %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_magic_attribute   ////// PREDEFINED
{
  * comment  "predefined routine to emit magic_attribute-s" }
 %  ^filler_of_function( signature_1itm_to_val)
 
..


** emitter_of_plain_kind   ////// PREDEFINED
{
  * comment  "routine to emit play kind items" }
 %  ^filler_of_function( signature_1itm_to_val)
 
..


** event_processor   ////// PREDEFINED
{
  * comment  "describes the processing of external events" }
 
..


** extern   ////// PREDEFINED
{
  * comment  "for set of external items in operators" }
 
..


** fail   ////// PREDEFINED
{
  * comment  "opcode to return with failure" }
 
..


** fill_agenda
{
  * comment  "attribute in agenda to refill it" }
 
..


** filler_of_association   ////// PREDEFINED
{
  * comment  "filler routine for association items" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_function   ////// PREDEFINED
{
  * comment  "routine to fill loaded C functions" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_hashed_dict   ////// PREDEFINED
{
  * comment  "filler routine for hashed dictitems" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_hashed_set   ////// PREDEFINED
{
  * comment  "filler routine for hashed set items" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_item_queue   ////// PREDEFINED
{
  * comment  "filler for item_queue" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_magic_attribute   ////// PREDEFINED
{
  * comment  "function to fill a magic attribute" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** filler_of_plain_kind   ////// PREDEFINED
{
  * comment  "routine to fill plain kind items" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** formals   ////// PREDEFINED
{
  * comment  "attribute giving the tuple of formals" }
 
..


** function_info   ////// PREDEFINED
{
  * comment  "gives internal information about functions" }
 
..


** function_radix   ////// PREDEFINED
{
  * comment  "gives the radix of names related to signatures & functions"
 }
 
..


** function_signature   ////// PREDEFINED
{
  * comment  "kind of function signatures"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** functions   ////// PREDEFINED
{
  * comment  "in a C module, attribute giving the set or tuple of functions, or a closure to compute them"
 }
 
..


** generate_c_module   ////// PREDEFINED
{
  * comment  "routine to generate a C module; returns the item on success, or an error message"
  * hook_closure  0 }
 [[  ^generate_c_module() ]]
 %  ^filler_of_function( signature_1itm_to_val)
 
..


** hashed_dict   ////// PREDEFINED
{
  * comment  "kind of item with hashed dict"
  * dumped_item_emitter  ^emitter_of_hashed_dict()
  * dumped_item_scanner  ^scanner_of_hashed_dict() }
 
..


** hashed_set   ////// PREDEFINED
{
  * comment  "kind of item with hashed set payload"
  * dumped_item_emitter  ^emitter_of_hashed_set()
  * dumped_item_scanner  ^scanner_of_hashed_set() }
 
..


** hook_closure   ////// PREDEFINED
{
  * comment  "attribute to give the hook closure in predefined functions"
 }
 
..


** http_GET   ////// PREDEFINED
{
  * comment  "predefined for HTTP web GET requests" }
 
..


** http_HEAD   ////// PREDEFINED
{
  * comment  "predefined for HTTP web HEAD requests" }
 
..


** http_POST   ////// PREDEFINED
{
  * comment  "predefined for HTTP web POST requests" }
 
..


** if   ////// PREDEFINED
{
  * comment  "opcode for if <expr> <then-block> instruction" }
 
..


** in   ////// PREDEFINED
{
  * comment  "attribute giving some container information" }
 
..


** input_types   ////// PREDEFINED
{
  * comment  "give the tuple of input types inside signatures" }
 
..


** instructions   ////// PREDEFINED
{
  * comment  "attribute giving the tuple of instruction inside a block" }
 
..


** int_switch   ////// PREDEFINED
{
  * comment  "operation for switch on integer: int_switch <expr> <case>..."
 }
 
..


** integer   ////// PREDEFINED
{
  * code  "intptr_t"
  * comment  "type for intptr_t"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 %  ^filler_of_plain_kind( type)
 
..


** integer_add
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_add:*/(("  num1  ") + ("
    num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_add: operator for integer +"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_different
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_different:*/(("  num1  ") != ("
    num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_different: operator for integer != test"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_div
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_div:*/(("  num1  ") / ("
    num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_div: operator for integer *"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_equal
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_equal:*/(("  num1  ") == ("
    num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_equal: operator for integer == test"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_greater_or_equal
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_greater_or_equal:*/(("  num1
    ") >= ("  num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_greater_or_equal: operator for integer >= test"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_greater_than
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_greater_than:*/(("  num1
    ") > ("  num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_greater_than: operator for integer > test"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_less_or_equal
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_less_or_equal:*/(("  num1
    ") <= ("  num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_less_or_equal: operator for integer <= test"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_less_than
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_less_than:*/(("  num1  ") < ("
    num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_less_than: operator for integer < test"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_mod
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_mod:*/(("  num1  ") % ("
    num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_mod: operator for integer %"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_mul
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_mul:*/(("  num1  ") * ("
    num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_mul: operator for integer *"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_sub
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*integer_sub:*/(("  num1  ") - ("
    num2  ")) ")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "integer_sub: operator for integer -"
  * formals  [num1 num2]
  * type  integer }
 
..


** integer_type
{
  * code  "momty_int"
  * comment  "integer constant for integer value type"
  * in  integer }
 %  ^filler_of_plain_kind( integer)
 
..


** item   ////// PREDEFINED
{
  * code  "momitem_t*"
  * comment  "type for momitem_t*" }
 %  ^filler_of_plain_kind( type)
 
..


** item_has_kind
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*item_has_kind:*/"  itm1  " && " 
   itm1  "->itm_kind =="  itm2)
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "test if an item itm1 has kind itm2"
  * formals  [itm1 itm2]
  * type  integer }
 %  ^filler_of_plain_kind( code_operation)
 
..


** item_queue   ////// PREDEFINED
{
  * comment  "kind of queueitem-payloaded items"
  * dumped_item_emitter  ^emitter_of_item_queue()
  * dumped_item_scanner  ^scanner_of_item_queue() }
 
..


** item_switch   ////// PREDEFINED
{
  * comment  "operation for switch on item: item_switch <expr> <case>..."
 }
 
..


** item_type
{
  * code  "momty_item"
  * comment  "integer constant for item value type"
  * in  item }
 %  ^filler_of_plain_kind( integer)
 
..


** itm1
{
  * type  item }
 
..


** itm2
{
  * type  item }
 
..


** itmres
{
  * type  item }
 
..


** itmvar_funsig
{
  * comment  "the item variable for the function_signature"
  * type  item }
 %  ^filler_of_plain_kind( variable)
 
..


** itmvar_tasklet
{
  * comment  "the item variable for the tasklet"
  * type  item }
 %  ^filler_of_plain_kind( variable)
 
..


** json   ////// PREDEFINED
{
  * comment  "kind of temporary JSON items" }
 
..


** jump   ////// PREDEFINED
{
  * comment  "operation for jump instruction" }
 
..


** kind   ////// PREDEFINED
{
  * comment  "very magic pseudo attribute giving the kind of items" }
 
..


** kind_constructor   ////// PREDEFINED
{
  * comment  "attribute giving an item -> void closure for constructing some kind"
 }
 
..


** leader_block   ////// PREDEFINED
{
  * comment  "attribute marking leader blocks" }
 
..


** lkitm_agenda
{
  * comment  "the locked item for the agenda"
  * type  locked_item }
 %  ^filler_of_plain_kind( variable)
 
..


** lkitm_fun
{
  * comment  "the locked item for the function"
  * type  locked_item }
 %  ^filler_of_plain_kind( variable)
 
..


** lkitm_module
{
  * comment  "the locked item for the module"
  * type  locked_item }
 %  ^filler_of_plain_kind( variable)
 
..


** lkitm_tasklet
{
  * comment  "the locked item for the tasklet"
  * type  locked_item }
 %  ^filler_of_plain_kind( variable)
 
..


** locked_item   ////// PREDEFINED
{
  * code  "momlockeditem_t*"
  * comment  "type for \"momlockeditem_t*\"" }
 %  ^filler_of_plain_kind( type)
 
..


** magic_attribute   ////// PREDEFINED
{
  * comment  "kind of magic attributes"
  * dumped_item_emitter  ^emitter_of_magic_attribute()
  * dumped_item_scanner  ^scanner_of_magic_attribute() }
 
..


** node_type
{
  * code  "momty_node"
  * comment  "integer constant for node value type" }
 %  ^filler_of_plain_kind( integer)
 
..


** num
{
  * type  integer }
 
..


** num1
{
  * type  integer }
 
..


** num2
{
  * type  integer }
 
..


** origin   ////// PREDEFINED
{
  * comment  "attribute giving the origin" }
 
..


** output_types   ////// PREDEFINED
{
  * comment  "give the tuple of result types inside signatures" }
 
..


** plain_code_emitter
{
  * comment  "function to emit plain operator" }
 %  ^filler_of_function( signature_1itm1val_to_void)
 
..


** plain_code_type_scanner
{
  * comment  "function to scan plain operator" }
 %  ^filler_of_function( signature_1itm1val_to_item)
 
..


** plain_statement_emitter
{
  * comment  "function to emit statement with plain code_operation" }
 %  ^filler_of_function( signature_2itm_to_void)
 
..


** plain_statement_scanner
{
  * comment  "function to scan statement with plain code_operation" }
 %  ^filler_of_function( signature_2itm_to_void)
 
..


** pop_back_queue_item
{
  * code_expansion  ^code_expansion( "/*pop_back_queue_item:*/\n"  itmres
    " = (momitem_t*)NULL;\n"  "{if ("  itm1  " && "  itm1  "->itm_kind == "
    item_queue  ")\n"  "  "  itmres  " = mom_queueitem_pop_back((struct momqueueitems_st*)"
    itm1  "->itm_data1);}\n")
  * comment  "statement operation to pop back of queue item"
  * constants  {item_queue}
  * extern  {item_queue}
  * formals  [itm1]
  * results  [itmres]
  * statement_emitter  ^plain_statement_emitter()
  * statement_scanner  ^plain_statement_scanner() }
 %  ^filler_of_plain_kind( code_operation)
 
..


** pop_front_queue_item
{
  * code_expansion  ^code_expansion( "/*pop_front_queue_item:*/\n"  itmres
    " = (momitem_t*)NULL;\n"  "{if ("  itm1  " && "  itm1  "->itm_kind == "
    item_queue  ")\n"  "  "  itmres  " = mom_queueitem_pop_front((struct momqueueitems_st*)"
    itm1  "->itm_data1);}\n")
  * comment  "statement operation to pop front of queue item"
  * constants  {item_queue}
  * extern  {item_queue}
  * formals  [itm1]
  * results  [itmres]
  * statement_emitter  ^plain_statement_emitter()
  * statement_scanner  ^plain_statement_scanner() }
 %  ^filler_of_plain_kind( code_operation)
 
..


** preparation   ////// PREDEFINED
{
  * comment  "attribute giving the closure to prepare something, e.g. a code module"
 }
 
..


** push_back_queue_item
{
  * code_expansion  ^code_expansion( "/*push_back_queue_item:*/\n"  "{if ("
    itm1  " && "  itm1  "->itm_kind == "  item_queue  ")\n"  "   mom_queueitem_push_back((struct momqueueitems_st*)"
    itm1  "->itm_data1, "  itm2  ");}\n")
  * comment  "statement operation to push at back of queue item itm1 the item itm2"
  * constants  {item_queue}
  * extern  {item_queue}
  * formals  [itm1 itm2]
  * results  []
  * statement_emitter  ^plain_statement_emitter()
  * statement_scanner  ^plain_statement_scanner() }
 %  ^filler_of_plain_kind( code_operation)
 
..


** push_front_queue_item
{
  * code_expansion  ^code_expansion( "/*push_front_queue_item:*/\n"  "{if ("
    itm1  " && "  itm1  "->itm_kind == "  item_queue  ")\n"  "  mom_queueitem_push_front((struct momqueueitems_st*)"
    itm1  "->itm_data1, "  itm2  ");}\n")
  * comment  "statement operation to push at front of queue item itm1 the item itm2"
  * constants  {item_queue}
  * extern  {item_queue}
  * formals  [itm1 itm2]
  * results  []
  * statement_emitter  ^plain_statement_emitter()
  * statement_scanner  ^plain_statement_scanner() }
 %  ^filler_of_plain_kind( code_operation)
 
..


** queue_item_is_empty
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*queue_item_is_empty:*/"  itm1  " && "
    itm1  "->itm_kind =="  item_queue  " && mom_queueitem_size ("  itm1 
   "->itm_data1) == 0")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "test if a queue item is empty"
  * extern  {item_queue}
  * formals  [itm1]
  * type  integer }
 %  ^filler_of_plain_kind( code_operation)
 
..


** restitm
{
  * type  item }
 
..


** restval
{
  * type  value }
 
..


** results   ////// PREDEFINED
{
  * comment  "give result formals for plain statement operations" }
 
..


** runner   ////// PREDEFINED
{
  * comment  "gives the closure to run a tasklet" }
 
..


** scanner_of_association   ////// PREDEFINED
{
  * comment  "scanner routine for association items" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** scanner_of_function   ////// PREDEFINED
{
  * comment  "scanning routine for C functions, may add their containing module"
 }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** scanner_of_hashed_dict   ////// PREDEFINED
{
  * comment  "scanner for hashed dict items" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** scanner_of_hashed_set   ////// PREDEFINED
{
  * comment  "scanner routine for hashed set items" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** scanner_of_item_queue   ////// PREDEFINED
{
  * comment  "scanner for item_queue" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** scanner_of_magic_attribute   ////// PREDEFINED
{
  * comment  "predefined routine to scan magic_attribute-s" }
 %  ^filler_of_function( signature_1itm_to_void)
 
..


** set   ////// PREDEFINED
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/set:*/ mom_setv_new("  count  ","
    restitm  ", NULL)")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operation for assignment instruction, also for making sets"
  * formals  []
  * type  value
  * variadic_count  count
  * variadic_rest  restitm }
 
..


** set_type
{
  * code  "momty_set"
  * comment  "integer constant for set value type"
  * in  set }
 %  ^filler_of_plain_kind( integer)
 
..


** should_stop
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*should_stop:*/ mom_should_stop()")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "test if mom should_stop"
  * formals  []
  * type  integer }
 %  ^filler_of_plain_kind( code_operation)
 
..


** signature_1itm1_to_item   ////// PREDEFINED

..


** signature_1itm1int_to_item   ////// PREDEFINED
{
  * comment  "signature for : item integer -> item"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm1int_to_item"
  * input_types  [item integer]
  * output_types  [item] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1itm1val1int_to_void   ////// PREDEFINED
{
  * comment  "signature for function: item value int -> ()"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm1val1int_to_void"
  * input_types  [item value integer]
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1itm1val_to_item   ////// PREDEFINED
{
  * comment  "signature of functions taking one item, one value and giving a value"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm1val_to_item"
  * input_types  [item value]
  * output_types  [item] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1itm1val_to_void   ////// PREDEFINED
{
  * comment  "signature of functions taking one item, one value and giving no results"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm1val_to_void"
  * input_types  [item value]
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1itm2val_to_void   ////// PREDEFINED
{
  * comment  "signature of functions taking one item, two values and giving no results"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm2val_to_void"
  * input_types  [item value value]
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1itm_to_item   ////// PREDEFINED
{
  * comment  "signature for : item  -> item"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm_to_item"
  * input_types  [item]
  * output_types  [item] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1itm_to_val   ////// PREDEFINED
{
  * comment  "signature for function of 1 item argument and 1 value result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm_to_val"
  * input_types  [item]
  * output_types  [value] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1itm_to_void   ////// PREDEFINED
{
  * comment  "signature for function of 1 item argument and no result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1itm_to_void"
  * input_types  [item]
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1val1int_to_void   ////// PREDEFINED
{
  * comment  "signature for closures : value int -> void"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1val1int_to_void"
  * input_types  [value integer]
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1val_to_val   ////// PREDEFINED
{
  * comment  "signature for closures with one value argument and one value result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1val_to_val"
  * input_types  [value]
  * output_types  [value] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_1val_to_void   ////// PREDEFINED
{
  * comment  "signature for closures with one value argument and no result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "1val_to_void"
  * input_types  [value]
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm1int_to_item   ////// PREDEFINED
{
  * comment  "signature for : item item integer -> item"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2itm1int_to_item"
  * input_types  [item item integer]
  * output_types  [value] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm1int_to_void   ////// PREDEFINED
{
  * comment  "signature for : item item int -> void"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2itm1int_to_void"
  * input_types  [item item integer]
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm1val_to_val   ////// PREDEFINED
{
  * comment  "signature of functions taking two items and a value and giving a value"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2itm1val_to_val"
  * input_types  [item item value]
  * output_types  [value] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm1val_to_void   ////// PREDEFINED
{
  * comment  "signature of functions taking two items and a value and giving no result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2itm1val_to_void"
  * input_types  [item item value]
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm2val_to_void   ////// PREDEFINED
{
  * comment  "signature of functions taking two items, two values and giving no results"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2itm2val_to_void"
  * input_types  [item item value value]
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm_to_val   ////// PREDEFINED
{
  * comment  "signature of functions taking two items and giving one value"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2itm_to_val"
  * input_types  [item item]
  * output_types  [value] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2itm_to_void   ////// PREDEFINED
{
  * comment  "signature of functions taking two items giving no result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2itm_to_void"
  * input_types  [item item]
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_2val_to_val   ////// PREDEFINED
{
  * comment  "signature of functions : value value -> value"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "2val_to_val"
  * input_types  [value value]
  * output_types  [value] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** signature_void_to_void   ////// PREDEFINED
{
  * comment  "signature for closures with no arguments and no result"
  * dumped_item_emitter  ^emitter_of_function()
  * dumped_item_scanner  ^scanner_of_function()
  * function_radix  "void_to_void"
  * input_types  []
  * output_types  [] }
 %  ^filler_of_plain_kind( function_signature)
 
..


** start   ////// PREDEFINED
{
  * comment  "attribute giving the starting attribute" }
 
..


** statement_emitter   ////// PREDEFINED
{
  * comment  "attribute giving the emitting closure in code operations" }
 
..


** statement_scanner   ////// PREDEFINED
{
  * comment  "attribute giving the scanning closure in code operations" }
 
..


** string_type
{
  * code  "momty_string"
  * comment  "integer constant for string value type" }
 %  ^filler_of_plain_kind( integer)
 
..


** success   ////// PREDEFINED
{
  * comment  "opcode to return successfully" }
 
..


** tasklet   ////// PREDEFINED
{
  * comment  "kind for tasklets inside the_agenda" }
 
..


** the_agenda   ////// PREDEFINED
{
  * comment  "agenda queue of tasklets" }
 %  ^filler_of_item_queue( [])
 
..


** the_base_module   ////// PREDEFINED
{
  * comment  "the base module, notably for agenda functions"
  * emitted_functions  {agenda_push_back agenda_push_front agenda_step append_function_to_closed_module}
  * functions  {agenda_push_back agenda_push_front agenda_step append_function_to_closed_module}
 }
 %  ^filler_of_plain_kind( code_module)
 
..


** the_software   ////// PREDEFINED
{
  * comment  "describes the entire software system"
  * item  {collect_set collect_tuple delim_type double_type integer_add integer_different
   integer_div integer_equal integer_greater_or_equal integer_greater_than
   integer_less_or_equal integer_less_than integer_mod integer_mul integer_sub
   integer_type item_type node_type plain_code_emitter plain_code_type_scanner
   plain_statement_emitter plain_statement_scanner pop_back_queue_item pop_front_queue_item
   push_back_queue_item push_front_queue_item queue_item_is_empty set_type
   string_type test_module this_closure tuple tuple_type type_of_value unsync_get_attribute
   unsync_put_attribute value_is_node value_is_sequence value_is_set value_is_tuple
   value_node_arity value_node_conn value_node_nth value_of_item value_sequence_length
   value_sequence_nth value_to_item} }
 
..


** this_closure
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*this_closure:*/ mom_nodev(mom_node)")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operation to give the current closure\'s value"
  * formals  []
  * type  value }
 
..


** this_statement   ////// PREDEFINED
{
  * comment  "in a chunk code statement or an operator, is expanded to the statement item"
 }
 
..


** tuple
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/tuple:*/ mom_make_tuple("  count 
   ","  restitm  ", NULL)")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operation for making tuples"
  * formals  []
  * type  value
  * variadic_count  count
  * variadic_rest  restitm }
 
..


** tuple_type
{
  * code  "momty_tuple"
  * comment  "integer constant for tuple value type"
  * in  tuple }
 %  ^filler_of_plain_kind( integer)
 
..


** type   ////// PREDEFINED
{
  * comment  "kind of code types, etc.."
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** type_of_value
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*type_of_value:*/ ((intptr_t) (" 
   val1  ").typnum)")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator giving the type of some value val1"
  * formals  [val1]
  * type  integer }
 
..


** unsync_get_attribute
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*unsync_get_attribute:*/mom_item_unsync_get_attribute ("
    itm1  ","  itm2  ")")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "get an attribute"
  * formals  [itm1 itm2]
  * type  value }
 %  ^filler_of_plain_kind( code_operation)
 
..


** unsync_put_attribute
{
  * code_expansion  ^code_expansion( "/*unsync_put_attribute:*/"  " (void)mom_item_unsync_put_attribute(("
    itm1  "), ("  itm2  "), ("  val1  "));")
  * comment  "statement operation to put inside item itm1 the attribute itm2 to val1"
  * formals  [itm1 itm2 val1]
  * results  []
  * statement_emitter  ^plain_statement_emitter()
  * statement_scanner  ^plain_statement_scanner() }
 %  ^filler_of_plain_kind( code_operation)
 
..


** user   ////// PREDEFINED
{
  * comment  "attribute giving the user, etc..." }
 
..


** val1
{
  * type  value }
 
..


** val2
{
  * type  value }
 
..


** value   ////// PREDEFINED
{
  * code  "momvalue_t"
  * comment  "type for momvalue_t" }
 %  ^filler_of_plain_kind( type)
 
..


** value_is_node
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_is_node:*/ ("  val1  ").typnum == momty_node")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator testing that operand is a node"
  * formals  [val1]
  * type  integer }
 
..


** value_is_sequence
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_is_sequence:*/ mom_value_to_sequ("
    val1  ") != NULL")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator testing that operand is a sequence (tuple or set)"
  * formals  [val1]
  * type  integer }
 
..


** value_is_set
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_is_set:*/ ("  val1  ").typnum == momty_set")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator testing that operand is a set"
  * formals  [val1]
  * type  integer }
 
..


** value_is_tuple
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_is_tuple:*/ ("  val1  ").typnum == momty_tuple")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator testing that operand is a tuple"
  * formals  [val1]
  * type  integer }
 
..


** value_node_arity
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_node_arity:*/ (intptr_t)mom_node_arity(mom_value_to_node("
    val1  "))")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator giving for a value node val1 its arity"
  * formals  [val1]
  * type  integer }
 
..


** value_node_conn
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_node_conn:*/ mom_node_conn(mom_value_to_node("
    val1  "))")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator giving for a value node val1 its connective or else nil"
  * formals  [val1]
  * type  item }
 
..


** value_node_nth
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_node_nth:*/ mom_node_nth(mom_value_to_node("
    val1  "), ("  num  "))")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator giving for a value node val1 its son at rank num"
  * formals  [val1 num]
  * type  value }
 
..


** value_of_item
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_of_item:*/ mom_itemv("  itm1
    ")")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator to convert an item to a value"
  * formals  [itm1]
  * type  value }
 
..


** value_sequence_length
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_sequence_length:*/ mom_seq_length(mom_value_to_sequ("
    val1  "))")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator giving the length of a sequence value"
  * formals  [val1]
  * type  integer }
 
..


** value_sequence_nth
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_sequence_nth:*/ (momitem_t*)mom_seq_nth(mom_value_to_sequ("
    val1  "), (int)("  num  "))")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator giving for a value sequence val1 its component of rank num"
  * formals  [val1 num]
  * type  item }
 
..


** value_to_item
{
  * code_emitter  ^plain_code_emitter()
  * code_expansion  ^code_expansion( "/*value_to_item:*/ mom_value_to_item("
    val1  ")")
  * code_type_scanner  ^plain_code_type_scanner()
  * comment  "operator to convert a value to an item"
  * formals  [val1]
  * type  item }
 
..


** valvar_funcset
{
  * comment  "the value variable for the functions set"
  * type  value }
 %  ^filler_of_plain_kind( variable)
 
..


** valvar_newfuncset
{
  * comment  "the value variable for the updated functions set"
  * type  value }
 %  ^filler_of_plain_kind( variable)
 
..


** varclo
{
  * comment  "variable for a closure"
  * type  value }
 %  ^filler_of_plain_kind( variable)
 
..


** variable   ////// PREDEFINED
{
  * comment  "kind of variable, or attribute giving a set of variables"
  * dumped_item_emitter  ^emitter_of_plain_kind() }
 
..


** variadic_count   ////// PREDEFINED
{
  * comment  "in plain connectives, gives item bound to count of remaining arguments"
 }
 
..


** variadic_rest   ////// PREDEFINED
{
  * comment  "in plain connectives, gives item bound to rest of arguments"
 }
 
..


** varix
{
  * comment  "variable for an index"
  * type  integer }
 %  ^filler_of_plain_kind( variable)
 
..


** varlen
{
  * comment  "variable for a length"
  * type  integer }
 %  ^filler_of_plain_kind( variable)
 
..


** void   ////// PREDEFINED
{
  * code  "void"
  * comment  "type for C \'void\' type" }
 %  ^filler_of_plain_kind( type)
 
..


** web_exchange   ////// PREDEFINED
{
  * comment  "kind of transient web request/response exchange" }
 
..


** web_processor   ////// PREDEFINED
{
  * comment  "dictionnary of web handlers" }
 %  ^filler_of_hashed_dict( ^in( "/foo"  ^itm2( "for /foo"  1))  ^in( "/foo/bar"
         ^itm1( "for /foo/bar"  2)))
 
..


** web_session   ////// PREDEFINED
{
  * comment  "kind of transient items for web sessions" }
 
..


** websocket_handler   ////// PREDEFINED
{
  * comment  "attribute giving the websocket handler of incoming JSON" }
 
..

//// end of global file global.mom
