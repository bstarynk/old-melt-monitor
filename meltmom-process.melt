;;;  file meltmom-process.melt -*- Lisp -*-

;;;   Copyright (C)  2014 Free Software Foundation, Inc.
;;; MONIMELT is a monitor for MELT - see http://gcc-melt.org/
;;; This file is part of GCC.
;;;
;;; GCC is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 3, or (at your option)
;;; any later version.
;;;
;;; GCC is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;; You should have received a copy of the GNU General Public License
;;; along with GCC; see the file COPYING3.   If not see
;;; <http://www.gnu.org/licenses/>.

;;; this file is for the MELT 1.1.2 (or later) plugin for GCC
;;; to process the header file monimelt.h
;;; see http://gcc-melt.org/ for more

(module_is_gpl_compatible "GPLv3+")

(definstance monimelt_pragma_ok class_reference)

(defvar monimelt_types_list)
(setq monimelt_types_list (list))
(defvar monimelt_functions_list)
(setq monimelt_functions_list (list))
(defvar monimelt_tmp)
(setq monimelt_tmp (constant_box (melt_argument "monimelt-tmp")))
(debug "monimelt_tmp=" monimelt_tmp)
(defvar monimelt_service)
(setq monimelt_service
      (let ( (monimelt_socket (melt_argument "monimelt-socket"))
	     )
	(if monimelt_socket (constant_box monimelt_socket)
	  (string4out discr_string monimelt_tmp "_socket"))))
;; we need to usleep a bit to let the monitor warm up
(code_chunk startusleep_chk #{ /* meltmom-process $STARTUSLEEP_CHK */
	    usleep (200*1000);
	    }#)
(debug "monimelt_service=" monimelt_service)
(defun monimelt_enable_pragma_handler (ph)
  (debug "monimelt_enable_pragma_handler ph=" ph)
  (inform_at (pragma_lex) "MONIMELT enabling MELT")
  (set_ref monimelt_pragma_ok :true)
)

(defun monimelt_disable_pragma_handler (ph)
  (debug "monimelt_disable_pragma_handler ph=" ph)
  (set_ref monimelt_pragma_ok ())
)

(defun monimelt_attribute_handler (attr flaglist :tree tr_node tr_name tr_args) 
  (debug "monimelt_attribute_handler" " start attr=" attr
	 "; flaglist=" flaglist
	 ";\n tr_node=" tr_node
	 ";\n tr_name=" tr_name
	 ";\n tr_args=" tr_args)
  (return)
)

(defun monimelt_finish_decl (decl)
  (if (null !monimelt_pragma_ok)
      (return)) 
  (let ( (tdecl  (unbox :tree decl))
	 )
    ;; (debug "monimelt_finish_decl" " begin tdecl=" tdecl "\n")
    (match
     tdecl
     (?(tree_function_decl_named
	?(and ?tfuname ?(cstring_prefixed "mom_"))
	?tfunres)
       (debug  "monimelt_finish_decl" " function tdecl=" tdecl)
       (list_append monimelt_functions_list decl)
       )
     (?(tree_type_declaration
	;; caveat, many types start with mom without underscore
	?(and ?(tree_identifier ?(cstring_prefixed "mom")) ?tyname))
       (debug "monimelt_finish_decl" " typedecl tyname=" tyname 
	      ";\n.. tdecl=" tdecl "\n")
       (list_append monimelt_types_list decl)
       )
     (?_
      ;; (debug "monimelt_finish_decl else tdecl=" tdecl)
      (void)
      )
     )
    )
  )


(defun monimelt_declare_type (typev)
  (debug "monimelt_declare_type" " start typev=" typev)
  (let ( (tr_type (unbox :tree typev))
	 )
    (debug "monimelt_declare_type" " tr_type=" tr_type)
    (match tr_type
	   ( ?(and
	       ?(tree_type_declaration ?(tree_identifier ?tyidstr))
	       ?(tree_decl_at_source_location ?filepathv ?linum ?colnum))
	      (debug "monimelt_declare_type" " tyidstr=" tyidstr
		     " linum=" linum)
	      (let ( (linenumv (constant_box linum))
		     (typenamev (constant_box tyidstr))
		     (jparam (make_jsonobject discr_jsonobject
					      'monimelt_name typenamev
					      'monimelt_line linenumv))
		     )
		(debug "monimelt_declare_type" " jparam=" jparam)
		(let ( (res (do_blocking_jsonrpc2_call monimelt_service
						       '"meltmom_declare_name" jparam 250)
			    )
		       )
		  (debug "monimelt_declare_type" " jsonrpc res=" res))
		)
	      )
	   ( ?_
	     (debug  "monimelt_declare_type" " strange tr_type=" tr_type)
	     (error_at typev "monimelt unexpected type $1" tr_type)
	     )
	   )
    )
  )

(defun monimelt_declare_function (funcv)
  (debug "monimelt_declare_function " "start funcv=" funcv)
  (let ( (tr_func (unbox :tree funcv))
	 )
    (debug "monimelt_declare_function" " tr_func=" tr_func)
    (match
     tr_func
     ( ?(and
	 ?(tree_function_decl_named ?funame ?funres)
	 ?(tree_decl_at_source_location ?filepathv ?linum ?colnum))
	(debug "monimelt_declare_function" " funame=" funame
	       " linum=" linum)
	(let ( (linenumv (constant_box linum))
	       (funcnamev (constant_box funame))
	       (jparam (make_jsonobject discr_jsonobject
					'monimelt_name funcnamev
					'monimelt_line linenumv))
	       )
	  (debug "monimelt_declare_function" " jparam=" jparam)
	  (let ( (res (do_blocking_jsonrpc2_call monimelt_service
						 '"meltmom_declare_name" jparam 350)
		      )
		 )
	    (debug "monimelt_declare_function" " jsonrpc res=" res))
	  )
	)
     ( ?_
       (debug "monimelt_declare_function" " strange tr_func=" tr_func)
       (error_at funcv "monimelt unexpected function $1" tr_func)
       )
     )
    )
  )


(defun monimelt_json_for_type (typev)
  (debug "monimelt_json_for_type" " start typev=" typev)
  (let ( (tr_type (unbox :tree typev))
	 )
    (assert_msg "monimelt_json_for_type check tr_type" tr_type typev)
    (match tr_type
	   ;;
	   (?(tree_char_type_node)
	     (debug  "monimelt_json_for_type" " char")
	     (return '"char")
	     )
	   ;;
	   (?(tree_signed_char_type_node)
	     (debug  "monimelt_json_for_type" " signed char")
	     (return '"signed-char")
	     )
	   ;;
	   (?(tree_unsigned_char_type_node)
	     (debug  "monimelt_json_for_type" " unsigned char")
	     (return '"unsigned-char")
	     )
	   ;;
	   (?(tree_short_integer_type_node)
	     (debug  "monimelt_json_for_type" " short")
	     (return '"short")
	     )
	   ;;
	   (?(tree_short_unsigned_type_node)
	     (debug  "monimelt_json_for_type" " unsigned short")
	     (return '"unsigned-short")
	     )
	   ;;
	   (?(tree_integer_type_node)
	     (debug  "monimelt_json_for_type" " int")
	     (return '"int")
	     )
	   ;;
	   (?(tree_unsigned_type_node)
	     (debug  "monimelt_json_for_type" " unsigned")
	     (return '"unsigned")
	     )
	   ;;
	   (?(tree_long_integer_type_node)
	     (debug  "monimelt_json_for_type" " long")
	     (return '"long")
	     )
	   ;;
	   (?(tree_long_unsigned_type_node)
	     (debug  "monimelt_json_for_type" " unsigned long")
	     (return '"long")
	     )
	   ;;
	   (?(tree_size_type_node)
	     (debug  "monimelt_json_for_type" " size_t")
	     (return '"long")
	     )
	   ;;
	   (?(tree_integer_type ?tr_intype ?minv ?maxv ?tr_size)
	     (debug "monimelt_json_for_type" " integertype minv=" minv " maxv=" maxv
		    " tr_size=" tr_size)
	     (let (
		   (jintype (monimelt_json_for_type (constant_box tr_intype)))
		   (jres (make_jsonobject discr_jsonobject
					   'monimelt_integer_type jintype
					   )
			  ) 
		    )
	       (debug "monimelt_json_for_type" " integertype jres=" jres)
	       (return jres)
	       ))
	   (?(tree_pointer_type ?tr_pointedtype)
	     (debug "monimelt_json_for_type" " pointer tr_pointedtype=" tr_pointedtype)
	     (let ( (jpointedtype (monimelt_json_for_type (constant_box tr_pointedtype)))
		    (jres (make_jsonobject discr_jsonobject
					   'monimelt_pointer_type jpointedtype))
		    )
	       (debug "monimelt_json_for_type" " pointertype jres=" jres)
	       (return jres)
	     ))
	   (?_ 
	    (assert_msg "monimelt_json_for_type unexpected tr_type" () tr_type)
	    (void)))
))



(defun monimelt_declare_aggregate_field (aggnamev fieldv :long ix)
  (debug "monimelt_declare_aggregate_field" " aggnamev=" aggnamev
	 " fieldv=" fieldv "\n.. ix=" ix)
  (let ( (tr_field (unbox :tree fieldv))
	 )
    (debug "monimelt_declare_aggregate_field" " tr_field=" tr_field)
    (match tr_field
	   (?(and
	      ?(tree_field_decl ?(tree_identifier ?fldnamestr) ?tr_fldtype)
	      ?(tree_decl_at_source_location ?filepathv ?linum ?colnum))
	     (debug "monimelt_declare_aggregate_field "
		    " fldnamestr=" fldnamestr
		    " tr_fldtype=" tr_fldtype "\n.. linum=" linum)
	     (match tr_fldtype
		    (?(tree_integer_type ?tr_intype ?minv ?maxv ?tr_size)
		      (debug "monimelt_declare_aggregate_field" " fldtype integer tr_intype=" tr_intype
			     " minv=" minv " maxv=" maxv " tr_size=" tr_size)
		      (let ( (jparams (make_jsonobject discr_jsonobject
						       'monimelt_name fldnamestr
						       'monimelt_line linum
						       ))
			     )
			(debug "monimelt_declare_aggregate_field" " integer: jparams=" jparams)
			(void)
			)
		      )
		    (?(tree_real_type ?tr_realname ?tr_realsize)
		      (debug "monimelt_declare_aggregate_field" " fldtype real tr_realname=" tr_realname)
		      (void))
		    (?(tree_pointer_type ?tr_pointedtype)
		      (debug "monimelt_declare_aggregate_field" " fldtype pointer tr_pointedtype=" tr_pointedtype)
		      (void))
		    (?(tree_union_type ?tr_unitype)
		      (debug "monimelt_declare_aggregate_field" " fldtype union tr_unitype=" tr_unitype)
		      (void))
		    (?(tree_array_type ?tr_arrelemtype ?tr_arrdomaintype)
		      (debug "monimelt_declare_aggregate_field" " fldtype pointer array tr_arrelemtype=" tr_arrelemtype
			     " tr_arrdomaintype=" tr_arrdomaintype)
		      (void))
		    (?_
		     (debug "monimelt_declare_aggregate_field" " other fldnamestr=" fldnamestr
			    " type tr_fldtype=" tr_fldtype)
		     (void)))
	     (void))
	   (?_ (assert_msg "impossible tr_field" () tr_field)
	       (void)))
    )
  )

(defun monimelt_fill_type (typev)
  (debug "monimelt_fill_type" " start typev=" typev)
  (let ( (tr_type (unbox :tree typev))
	 )
    (debug "monimelt_fill_type" " tr_type=" tr_type)
    (match tr_type
	   ( ?(tree_type_declaration ?(tree_identifier ?tyidstr))
	      (let ( (tr_srctype (tree_type tr_type))
		     )
		(debug "monimelt_fill_type" " tr_srctype=" tr_srctype)
		(match tr_srctype
		       ( ?(tree_integer_type ?tr_basetype ?minv ?maxv ?tr_size)
			  (debug "monimelt_fill_type" " integral tr_basetype=" tr_basetype
				 " minv=" minv " maxv=" maxv " tr_size=" tr_size))
		       ( ?(tree_record_type_with_fields ?tr_recname ?tr_recfields)
			  (debug "monimelt_fill_type" " record tr_recname=" tr_recname
				 " tr_recfields=" tr_recfields)
			  (let ( (fieldstup (tree_chain_to_tuple discr_multiple tr_recfields))
				 )
			    (debug "monimelt_fill_type" " fieldstup=" fieldstup)
			    (foreach_in_multiple
			     (fieldstup)
			     (curfieldv :long ix)
			     (debug "monimelt_fill_type" " curfieldv=" curfieldv "; ix=" ix)
			     (monimelt_declare_aggregate_field (constant_box tyidstr) curfieldv ix)
			     )
			    )
			  )
		       ( ?(tree_union_type_with_fields ?tr_uniname ?tr_unifields)
			  (debug "monimelt_fill_type" " union tr_uniname=" tr_uniname
				 " tr_unifields=" tr_unifields)
			  )
		       ( ?_
			 (debug "monimelt_fill_type" " strange type tr_type=" tr_type)
			 (warning_at typev "monimelt strange type $1" tr_type)
			 )
		       )
		)
	      )
	   (?_
	    (assert_msg "unexpected typev" () typev)))
    )
  )

;;this function should probably do the JSONRPC calls
(defun monimelt_finish_unit (arg)
  (debug "monimelt_finish_unit" " arg=" arg ";\n monimelt_types_list=" monimelt_types_list
	 ";\n monimelt_functions_list=" monimelt_functions_list)
  ;;
  (debug "monimelt_functions_list" " declaring " (list_length monimelt_types_list) " types")
  (each_component_in_list
   monimelt_types_list
   ctype
   (monimelt_declare_type ctype))
  ;;
  (debug "monimelt_functions_list" " declaring " (list_length monimelt_functions_list) " functions")
  (each_component_in_list
   monimelt_functions_list
   cfunc
   (monimelt_declare_function cfunc))
  ;;
  (debug "monimelt_functions_list" " filling " (list_length monimelt_types_list) " types")
  (each_component_in_list
   monimelt_types_list
   ctype
   (monimelt_fill_type ctype))
  ;;
  (let ( (momdump (do_blocking_jsonrpc2_call monimelt_service '"dump" () 1550))
	 )
    (when (null momdump)
      (error_at () "failed to do final Monimelt dump on service $1" monimelt_service)
      (return))
    (debug "monimelt_finish_unit" " momdump=" momdump))
  )


(defun processmonimelt_docmd (cmd moduldata)
  (debug "processmonimelt_docmd start " cmd)
  (debug "processmonimelt_docmd monimelt_service=" monimelt_service)
  (let ( (momstatus (do_blocking_jsonrpc2_call monimelt_service '"state" '1 660))
	 (at (instance class_gcc_attribute
		       :named_name '"meltmom"
		       :gccattr_data (tuple 'some-data)
		       :gccattr_handler monimelt_attribute_handler))
	 )
    (debug "processmonimelt_docmd" " initial momstatus=" momstatus
	   "\n.. at=" at)
    (when (null momstatus)
      (error_at () "failed to get Monimelt initial state on service $1" monimelt_service)
      (return))
    (register_expanded_pragma 'monimelt 'enable
			      monimelt_enable_pragma_handler 
			      :true)
    (register_expanded_pragma 'monimelt 'disable
			      monimelt_disable_pragma_handler 
			      ())
    (register_gcc_attribute at :min_length 1)
    (register_finish_decl_first  monimelt_finish_decl)
    (at_finish_unit_first monimelt_finish_unit)
  
    (debug "processmonimelt_docmd end " cmd)
    (inform_at () "done MELT processing of monimelt.h")
    ;; at last
    (return :true)
    ))


(definstance process_monimelt_header_mode
  class_melt_mode
  :named_name '"process_monimelt_header"
  :meltmode_help '"process the monimelt.h header file and send some information about it to monimelt using JSONRPC"
  :meltmode_fun processmonimelt_docmd
)
(install_melt_mode process_monimelt_header_mode)
;; eof meltmom-process.melt 
